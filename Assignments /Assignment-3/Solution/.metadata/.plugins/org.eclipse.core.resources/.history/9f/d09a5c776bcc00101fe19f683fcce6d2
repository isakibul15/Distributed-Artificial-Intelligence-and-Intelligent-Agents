/**
* Name: Task-1 Queen
* Based on the internal empty template. 
Author: Sakib, Ahsan, Sing
* Tags: 
*/
model NQueen

global {
    int N <- 12;
    list<map> solutions <- [];
    bool searching <- true;
    int max_solutions <- 1;
    bool algorithm_started <- false;
    float cell_size <- 100.0 / N;
    
    init {
        loop i from: 0 to: N-1  {
    		create queen{
    			indexInArray <- i;
    		}
    			}
    }
    
    reflex start_algorithm when: !algorithm_started and length(queen) = N {
        algorithm_started <- true;
        write "========================================";
        write "Starting N-Queens algorithm";
        write "========================================";
        
        // Trigger first queen to start
        queen first_queen <- queen(0);
        first_queen.should_start <- true;
    }
}

species queen skills: [fipa] {
    int indexInArray;
    int myRow;
    list<int> possible_columns <- [];
    int col_index <- 0;
    int my_col <- -1;
    
    bool placed <- false;
    bool initialized <- false;
    bool should_start <- false;
    bool waiting_for_validation <- false;
    int pending_column <- -1;
    
    rgb color <- #blue;
    
    // Initialize columns on first step
    reflex init_columns when: !initialized {
        loop i from: 0 to: N - 1 {
            add i to: possible_columns;
        }
        initialized <- true;
        write "Queen " + indexInArray + " initialized with columns: " + possible_columns;
    }
    
    // Start algorithm when triggered
    reflex start when: should_start and initialized {
        should_start <- false;
        write "Queen " + indexInArray + " starting placement";
        do try_place;
    }

	action checkForPredecessor(int test_col) {
		// Send validate message to my predecessor
		waiting_for_validation <- true;
		pending_column <- test_col;
		
		if(indexInArray = 0){
			// Queen 0 validates herself - always true
			do start_conversation(
				to :: [self],
				protocol :: 'fipa-request',
				performative :: 'inform',
				contents :: ['result', true]
			);
			return;
		}
		write "queen" + indexInArray + "sending validate request";
		do start_conversation(
			to :: [queen[indexInArray - 1]],
			protocol :: 'fipa-request',
			performative :: 'request',
			contents :: ['validate', test_col, indexInArray]
		);
	}
    
	reflex handle_fipa_messages when: (!empty(requests) or !empty(informs)) {
		
		loop m over: requests {
			list data <- list(m.contents);
			string msg_type <- string(data[0]);
			
			if (msg_type = "TRY") {
				col_index <- 0;
				placed <- false;
				color <- #blue;
				my_col <- -1;
				write "Queen " + indexInArray + " received TRY with config: " ;
				do try_place;
			}
			else if (msg_type = "BACKTRACK") {
				write "Queen " + indexInArray + " received BACKTRACK";
				col_index <- col_index + 1;
				placed <- false;
				my_col <- -1;
				color <- #orange;
				do try_place;
			}
			else if(msg_type = 'validate') {
				int test_col <- int(data[1]);
				int asker_row <- int(data[2]);
				
				// Check if it conflicts with my position
				bool conflicts <- false;
				if(my_col >= 0) {
					if(my_col = test_col) {
						conflicts <- true;
					}
					if(abs(indexInArray - asker_row) = abs(my_col - test_col)) {
						conflicts <- true;
					}
				}
				
				if(indexInArray = 0) {
					// Queen 0 gives final decision
					write "answer from final queen is " + conflicts;
					do start_conversation(
						to::[queen[asker_row]],
						protocol :: 'fipa-request',
						performative :: 'inform',
						contents :: ['result', !conflicts]
					);

				} else {
					if(conflicts) {
						// Immediate conflict - reject
					do start_conversation(
						to::[queen[asker_row]],
						protocol :: 'fipa-request',
						performative :: 'inform',
						contents :: ['result', !conflicts]
					);
					} else {
						// No conflict with me, forward to my predecessor
						do start_conversation(
							to :: [queen[indexInArray - 1]],
							protocol :: 'fipa-request',
							performative :: 'request',
							contents :: ['validate_forward', test_col, asker_row, m]
						);
					}
				}
			}
			else if(msg_type = 'validate_forward') {
				int test_col <- int(data[1]);
				int asker_row <- int(data[2]);
				message original_req <- message(data[3]);
				
				// Check if it conflicts with my position
				bool conflicts <- false;
				if(my_col >= 0) {
					if(my_col = test_col) {
						conflicts <- true;
					}
					if(abs(indexInArray - asker_row) = abs(my_col - test_col)) {
						conflicts <- true;
					}
				}
				
				if(indexInArray = 0) {
					// Queen 0 - send final result
					do start_conversation(
						to::[queen[asker_row]],
						protocol :: 'fipa-request',
						performative :: 'inform',
						contents :: ['result', !conflicts]
					);
				} else {
					if(conflicts) {
						// Immediate conflict - reject
					do start_conversation(
						to::[queen[asker_row]],
						protocol :: 'fipa-request',
						performative :: 'inform',
						contents :: ['result', !conflicts]
					);
					} else {
						// No conflict, keep forwarding
						do start_conversation(
							to :: [queen[indexInArray - 1]],
							protocol :: 'fipa-request',
							performative :: 'request',
							contents :: ['validate_forward', test_col, asker_row, original_req]
						);
					}
				}
			}
		}
		
		
		loop m over: informs {
			list data <- list(m.contents);
			string msg_type <- string(data[0]);
			
			if (msg_type = "SUCCESS") {
				map<int, int> solution <- map(data[1]);
				write "Queen " + indexInArray + " received SUCCESS: " + solution;
				
				bool already_exists <- false;
				loop existing_sol over: solutions {
					if (existing_sol = solution) {
						already_exists <- true;
						break;
					}
				}
				
				if (!already_exists) {
					add solution to: solutions;
					write "========================================";
					write "=== Solution #" + length(solutions) + " found ===";
					write solution;
					write "========================================";
				}
				
				if (indexInArray > 0) {
					do start_conversation (
						to :: [queen[indexInArray - 1]],
						protocol :: 'fipa-request',
						performative :: 'inform',
						contents :: ['SUCCESS', solution]
					);
				}
			}
			else if(msg_type = "result" and waiting_for_validation){
				bool is_valid <- bool(data[1]);
				waiting_for_validation <- false;
				
				write "Queen " + indexInArray + " received validation result: " + is_valid + " for column " + pending_column;
				
				if(is_valid) {
					my_col <- pending_column;
					placed <- true;
					color <- #green;
					
					location <- {(my_col+1) * cell_size, (indexInArray+1) * cell_size};
					write "  ✓ Queen " + indexInArray + " placed in column " + my_col;
					write "  ✓ Queen " + indexInArray + " placed at Row " + indexInArray + ", Col " + my_col + " location: " + location;
					write "  Grid bounds: 0 to " + (N-1);
					
					
					if (indexInArray < N - 1 ) {
						write "  → Sending TRY to Queen " + (indexInArray + 1);
						do start_conversation (
							to :: [queen[indexInArray + 1]],
							protocol :: 'fipa-request',
							performative :: 'request',
							contents :: ['TRY']
						);
					} 
					else {
						write "*** SOLUTION FOUND BY LAST QUEEN ***";
						color <- #gold;
						do start_conversation (
							to :: [queen[indexInArray - 1]],
							protocol :: 'fipa-request',
							performative :: 'inform',
							contents :: ['SUCCESS']
						);
					}
				}
				else{
					write "  ✗ Queen " + indexInArray + " rejected for column " + pending_column;
					col_index <- col_index + 1;
					pending_column <- -1;
					do try_place;
				}
			}
		}
	}

	action try_place {
		write "Queen " + indexInArray + " trying to place (col_index=" + col_index + ")";
		
		if (length(possible_columns) = 0) {
			write "ERROR: Queen " + indexInArray + " has empty possible_columns list!";
			return;
		}
		
		if(col_index < length(possible_columns) and !waiting_for_validation){
			int test_col <- possible_columns[col_index];
			write "  Testing column " + test_col;
			
			do checkForPredecessor(test_col);
			return; // Wait for validation response
		}
		
		if(col_index >= length(possible_columns)){
			write "  ✗ Queen " + indexInArray + " failed to place, backtracking";
			color <- #red;
			
			if (indexInArray > 0) {
				write "  ← Sending BACKTRACK to Queen " + (indexInArray - 1);
				do start_conversation (
					to :: [queen[indexInArray - 1]],
					protocol :: 'fipa-request',
					performative :: 'request',
					contents :: ['BACKTRACK']
				);
			} else {
				write "========================================";
				write "=== Search complete. Total solutions: " + length(solutions) + " ===";
				write "========================================";
				searching <- false;
			}
		}
	}
	
	aspect default {
			draw circle(cell_size*0.4) color: color border: #black;
			draw string(indexInArray) color: #white size: 8 at: location;
		
	}
}


experiment NQueens type: gui {
    parameter "Board Size (N)" var: N min: 4 max: 20 category: "Board";
    parameter "Max Solutions to Find" var: max_solutions min: 1 max: 100 category: "Search";
    
    output {
        display "N-Queens Board" type: 2d {
            graphics "Chessboard" {
    loop i from: 1 to: N {
        loop j from: 1 to: N {
            rgb cell_color <- ((i + j) mod 2 = 0) ? #white : #lightgray;
            draw square(cell_size) at: {j * cell_size, i * cell_size} color: cell_color border: #black;
        }
    }
    
    // Draw outer border frame
    draw rectangle(N * cell_size, N * cell_size) at: {(N+1) * cell_size / 2, (N+1) * cell_size / 2} color: #transparent border: #black width: 2;
    
   	 loop i from: 1 to: N {
        draw string(i) at: {i * cell_size, cell_size * 0.5} color: #black size: cell_size * 0.8;
    }
    
    loop i from: 1 to: N {
        draw string(i) at: {cell_size * 0.5, i * cell_size} color: #black size: cell_size * 0.8;
    }
            }
            
            species queen aspect: default;
        }
        
        display "Statistics" type: 2d {
            graphics "Info" {
                draw "N-Queens Problem Solver" at: {10, 20} color: #black font: font("Arial", 16, #bold);
                draw "Board Size: " + N at: {10, 50} color: #black font: font("Arial", 14, #plain);
                draw "Solutions Found: " + length(solutions) at: {10, 80} color: #black font: font("Arial", 14, #plain);
                draw "Status: " + (searching ? "Searching..." : "Complete") at: {10, 110} color: #black font: font("Arial", 14, #plain);
                
                draw "Legend:" at: {10, 150} color: #black font: font("Arial", 14, #bold);
                draw circle(5) at: {30, 180} color: #blue;
                draw "Trying" at: {50, 180} color: #black font: font("Arial", 12, #plain);
                
                draw circle(5) at: {30, 210} color: #green;
                draw "Placed" at: {50, 210} color: #black font: font("Arial", 12, #plain);
                
                draw circle(5) at: {30, 240} color: #orange;
                draw "Backtracking" at: {50, 240} color: #black font: font("Arial", 12, #plain);
                
                draw circle(5) at: {30, 270} color: #red;
                draw "Failed" at: {50, 270} color: #black font: font("Arial", 12, #plain);
                
                draw circle(5) at: {30, 300} color: #gold;
                draw "Solution!" at: {50, 300} color: #black font: font("Arial", 12, #plain);
            }
        }
        
        display "Solutions" type: 2d {
            graphics "Solution List" {
                draw "All Solutions Found:" at: {10, 20} color: #black font: font("Arial", 14, #bold);
                
                int y_pos <- 50;
                loop i from: 0 to: length(solutions) - 1 {
                    map sol <- solutions[i];
                    string sol_text <- "Solution " + (i + 1) + ": " + sol;
                    draw sol_text at: {10, y_pos} color: #black font: font("Arial", 12, #plain);
                    y_pos <- y_pos + 30;
                }
            }
        }
        
        monitor "Board Size (N)" value: N;
        monitor "Solutions Found" value: length(solutions);
        monitor "Currently Searching" value: searching;
        monitor "Queens Created" value: length(queen);
    }
}